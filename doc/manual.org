#+AUTHOR: Manuel Simoni
#+TITLE: Wat Language Manual
#+EMAIL: msimoni@gmail.com
#+OPTIONS: toc:2 num:nil creator:nil
#+STYLE: <link rel="stylesheet" type="text/css" href="stylesheet.css"/>

* Description

/Wat/ is a simple yet sophisticated Lisp for scripting interactive
networked applications.  Wat offers a nuanced set of features in three
main areas: For control abstraction, Wat combines first-order control
and resumable exceptions for quotidian control flow with multi-prompt
delimited continuations for advanced control inversions such as
cooperative multitasking.  For syntactic abstraction, Wat provides
lexically-scoped fexprs and first-class lexical environments, as well
as ordinary memoizing procedural macros for metaprogramming without
interpretetive overhead.  For data abstraction, Wat provides
first-class types, fully encapsulated objects, and generic functions.

Wat is hosted at <https://github.com/manuel/wat-js>.

This manual assumes familiarity with Kernel, Scheme, and Common Lisp.

Sections marked with /NIY/ are not implemented yet.

* Lexical Structure

Wat has a mostly Scheme-like lexical structure, incompletely described
by the following table:

| ; ...                                         | /line comment/               |
| . + - [0-9]+                                  | /number/                     |
| #t #f                                         | /logical constants/          |
| #void #ign                                    | /void and ignore constants/  |
| " ... "                                       | /string/                     |
| \\ \" \n \r \t                                | /escape character in string/ |
| ( ... )                                       | /list/                       |
| ( a b . c )                                   | /dotted list/                |
| ()                                            | /nil/                        |
| a-z A-Z 0-9 - & ! : = > < % + ? / * # $ _ ' . | /symbol characters/          |
| '<expr>                                       | /short for/ =(quote <expr>)= |

Wat identifiers are case-sensitive.

* Built-in Types

 * Void :: The constant =#void= is used when there is no interesting
   value to return, or when a value is unspecified.

 * Ignore :: The constant =#ign= is used in parameter lists to indicate
   that an argument is ignored and should not be bound in the
   combiner's environment.

 * Boolean :: The =#t= constant represents logical truth and the =#f=
   constant represents logical falsity.

 * Nil and Pair :: Lists are built from immutable pairs and nil.
   Notably, lists often contain not only symbols and literals (as is
   usual in Lisp) but also first-class objects such as combiners.

 * Symbol :: Symbols are used as identifiers for variable bindings.
   It is not guaranteed that symbols with the same name are pointer
   identical.

 * String :: Wat currently only supports UTF-16 encoded Unicode
   strings.

 * Number :: Wat supports a full Scheme-style numeric tower with
   arbitrary precision numbers.

 * Vector :: An array of objects.

 * Hashtable :: Wat currently only supports identity hashtables.

 * Operative :: A combiner that operates directly on its operands.

 * Applicative :: A combiner that evaluates its operands, yielding an
   arguments list, which it passes to an underlying combiner.

 * Macro :: Macros are used for optimization of syntactic abstraction.
   When a macro appears as first element of a compound form, the
   result of the macro will be evaluated instead of the original form.
   The result of the macro is memoized in the syntax tree, so every
   macro call is expanded only once, when it is first evaluated.

 * Environment :: An environment maps symbols to values.  It may have
   a parent environment in which symbols are looked up if they are not
   found in this environment.

 * Type :: A first-class type tag or just type is associated with
   every object.

 * Continuation :: Continuations are first-class objects, not wrapped
   in an applicative.

* Pattern Matching

As in Kernel, parameters and left-hand sides of definitions may not
only be symbols, but parameter trees: a parameter tree is either a
symbol, a cons, nil, or ignore.  A symbol binds the right hand to its
name, a cons recursively matches its car and cdr, nil matches only
nil, and ignore simply ignores the right-hand side.

Examples:

| Left-hand side | Right-hand side | Match results         |
|----------------+-----------------+-----------------------|
| a              | (1 (2) 3)       | a → (1 (2) 3)         |
| (a . b)        | (1 (2) 3)       | a → 1, b → ((2) 3)    |
| (a b c)        | (1 (2) 3)       | a → 1, b → (2), c → 3 |
| (a (b) . #ign) | (1 (2) 3)       | a → 1, b → 2          |

* Combiners

All computations in Wat are carried out by combiners, of which there
are two different kinds: operative and applicative (macros could also
be viewed as combiners, but are not discussed here).  An operative
combiner or just operative is a fexpr that receives the current
lexical environment and acts on its operand tree unevaluated.  An
applicative combiner or just applicative is a procedure that first
evaluates its operand tree and then passes the obtained arguments list
to an underlying combiner.  =vau= is the constructor of user-defined
operatives, called compound operatives.  =wrap= creates an applicative
around an underlying combiner.

Examples:

| Combiner                | Operand Tree  | Result                      |
|-------------------------+---------------+-----------------------------|
| =(vau x #ign x)=        | (1 (+ 2 3) 4) | (1 (+ 2 3) 4)               |
| =(vau #ign e e)=        | (1 (+ 2 3) 4) | /<the current environment>/ |
| =(wrap (vau x #ign x))= | (1 (+ 2 3) 4) | (1 5 4)                     |

* Bindings
** =def <lhs> <rhs> → rhs= [operative]

Evaluates the right-hand side, matches the left-hand side against it
in the current environment, and returns it.

=def= is the fundamental binding operator, others such as =define= and
=define-syntax= are defined in terms of it.

=def= allows binding multiple values, as well as destructuring.

*** Examples

#+BEGIN_EXAMPLE
(def x 1)
(assert (= x 1))

(def x 2)
(assert (= x 2))

(def (a b c) (list 1 (list 2) 3))
(assert (= a 1))
(assert (= b '(2)))
(assert (= c 3))

(def (a (b) c) (list 1 (list 2) 3))
(assert (= a 1))
(assert (= b 2))
(assert (= c 3))

(def (a . rest) (list 1 (list 2) 3))
(assert (= a 1))
(assert (= rest '((2) 3)))
#+END_EXAMPLE

** =define <lhs> <rhs> → result= [operative]

Scheme-like =define= with two cases:

 * =(define <name> <value>)= simply binds name to value, returning value.

 * =(define (<name> . <params>) . <body>)= binds name to an
   applicative with the given parameters and body expressions,
   returning the applicative.

*** Examples

#+BEGIN_EXAMPLE
(define foo 1)
(assert (= foo 1))

(define foo 2)
(assert (= foo 2))

(define (bar) 12)
(assert (= (bar) 12))

(define (bar x y) (+ x y))
(assert (= (bar 1 2) 3))

(define (times number . rest)
  (map (lambda (x) (* number x)) rest))
(assert (= (times 3 1 2 3 4) '(3 6 9 12)))
#+END_EXAMPLE

** =define-syntax <lhs> <rhs> → result= [operative]

Scheme-like =define-syntax= with two cases:

 * =(define-syntax <name> <value>)= simply binds name to value,
   returning value.

 * =(define-syntax (<name> . <params>) <envparam> . <body>)= binds
   name to an operative with the given parameters, environment
   parameter, and body expressions, returning the operative.

*** Examples

#+BEGIN_EXAMPLE
(define-syntax my-quote (vau (x) #ign x))
(assert (= (my-quote foo) 'foo))

(define-syntax (my-when test . exprs) env
  (if (eval test env) (eval (list* begin exprs) env) #void))
(assert (= (my-when #t 1 2 3) 3))
(assert (= (my-when #f 1 2 3) #void))
#+END_EXAMPLE

** =define-macro (<name> . <ptree>) . <body>= [operative]

Defines a new macro with the given name, parameter tree, and body.

*** Examples

#+BEGIN_EXAMPLE
(define-macro (my-let bindings . body)
  (cons (list* lambda (map car bindings) body)
        (map cadr bindings)))
(assert (= 3 (my-let ((x 1) (y 2))
               (+ x y))))

(define-macro (my-when test . exprs)
  (list if test (list* begin exprs) #void))
(assert (= (my-when #t 1 2 3) 3))
(assert (= (my-when #f 1 2 3) #void))
#+END_EXAMPLE

** =set! <env> <lhs> <rhs> → rhs= [operative]

Updates the left-hand side bindings by matching it against the
right-hand side in the given environment.

*** Examples

#+BEGIN_EXAMPLE
(define x 1)
(define x 2)

(set! (current-environment) x 3)
(set! (current-environment) y 4)
(assert (= x 3))
(assert (= y 4))

(set! (current-environment) (x y) (list y x))
(assert (= x 4))
(assert (= y 3))
#+END_EXAMPLE

** =defined? <sym> <env> → boolean= [applicative]

Returns true if a symbol is bound in the environment, false otherwise.

*** Examples

#+BEGIN_EXAMPLE
(define x 1)
(assert (defined? 'x (current-environment)))
(assert (not (defined? 'y (current-environment))))
#+END_EXAMPLE

** =provide <names> . <exprs> → result= [operative]

Performs expressions in a new lexical scope and exports only listed
names to the outer scope.

*** Examples

#+BEGIN_EXAMPLE
(provide (foo bar)
  (define foo 1)
  (define bar 2)
  (define quux 3)
)
(assert (= 1 foo))
(assert (= 2 bar))
(assert (not (defined? 'quux (current-environment))))
#+END_EXAMPLE

* Evaluation and Environments
** =make-environment [<parent>] → environment= [applicative]

Creates a new empty environment with the given optional parent.

*** Examples

#+BEGIN_EXAMPLE
(define e (make-environment))
(eval (list define 'x 1) e)
(assert (= 1 (eval 'x e)))

(define f (make-environment e))
(assert (= 1 (eval 'x f)))

(eval (list define 'x 2) f)
(assert (= 1 (eval 'x e)))
(assert (= 2 (eval 'x f)))
#+END_EXAMPLE

** =current-environment → environment= [applicative]

Returns the current environment.

*** Examples

#+BEGIN_EXAMPLE
(define x 1)
(assert (=  1 (eval 'x (current-environment))))

(define (foo)
  (let ((y 2))
    (current-environment)))
(assert (= 2 (eval 'y (foo))))
#+END_EXAMPLE

** =eval <expr> <env> → result= [applicative]

Evaluates the expression in the given environment.

*** Examples

#+BEGIN_EXAMPLE
(assert (= 4 (eval (list + 2 2) (current-environment))))
#+END_EXAMPLE

** =quote <form> → form= [operative]

Returns form unevaluated.

*** Examples

#+BEGIN_EXAMPLE
(assert (= '+ (car (quote (+ 2 2)))))
#+END_EXAMPLE

* Combiners
** =vau <ptree> <envp> <body> → operative= [operative]

Constructs a new compound operative that closes over the current
environment with the given parameter tree, environment parameter, and
body expression.

** =lambda <ptree> . <exprs> → applicative= [operative]

Creates an applicative combiner, as in Scheme.

** =apply <apv> <args> → result= [applicative]

Applies an applicative to an arguments list.

** =wrap <cmb> → applicative= [applicative]

Returns an applicative around an underlying combiner.

** =unwrap <cmb> → combiner= [applicative]

Returns the underlying combiner of an applicative.

* First-order Control
** =begin . <exprs> → result= [operative]

Evaluates expressions from left to right, returning the value of the
last.  As a special case, =(begin)= returns void.

** =if <test> <then> <else> → result= [operative]

Evaluates the test, and if it is false evaluates the else branch,
otherwise evaluates the then branch.

** =when <test> . <forms> → result= [operative]

Evaluates forms if test is true, returns void otherwise.

** =unless <test> . <forms> → result= [operative]

Evaluates forms if test is false, returns void otherwise.

** =loop . <forms> → |= [operative]

Infinite loop.

** =while <test> . <forms> → |= [operative]

Performs forms while test is true.

** =until <test> . <forms> → |= [operative]

Performs forms until test is true.

** =block <name> . <body> → result= [operative]

Performs body forms with name bound to a one-shot escape continuation
that can be invoked with =return-from=.

** =return-from <cont> <val> → |= [operative]

Invokes a one-shot escape continuation bound by =block=, passing it
the given value.

An error is signalled if the continuation's extent has ended.

** =unwind-protect <protected> . <cleanup> → result= [operative]

Executes and returns the value of the protected form.  When control
exits the protected form, either normally by a return, or abnormally
through an escape continuation, the cleanup forms are executed.  The
cleanup forms are not executed when the protected form is aborted by
higher-order control.

* Higher-order Control

These are the control operators from Dybvig, Jones, and Sabry's
[[http://www.cs.indiana.edu/~dyb/pubs/monadicDC.pdf][/A Monadic
Framework for Delimited Continuations/]] that are able to express all
other delimited control operators.

** =make-prompt → prompt= [applicative]

Creates a fresh prompt.

** =push-prompt <prompt> . <forms> → result= [applicative]

Pushes the continuation-delimiting prompt and executes forms in the
new continuation.

** =take-subcont <prompt> <cont> . <forms> → result= [applicative]

Aborts up to and including the prompt, and performs the forms with
=<cont>= bound to the delimited continuation from the call to
=take-subcont= up to but not including the prompt.

** =push-subcont <cont> . <forms> → result= [applicative]

Prepends the delimited continuation to the current continuation, and
performs forms in the new continuation.

*** Examples

#+BEGIN_EXAMPLE
(assert
  (= (let ((p (make-prompt)))
       (+ 2 (push-prompt p
              (if (take-subcont p k
                    (+ (push-subcont k #f)
                       (push-subcont k #t)))
                  3
                  4))))
     9))
#+END_EXAMPLE

* Dynamic Binding

These are the operators from Kiselyov, Shan, and Sabry's
[[http://okmij.org/ftp/papers/DDBinding.pdf][/Delimited Dynamic Binding/]].

** =dnew <val> → dynamic= [applicative]

Creates a new dynamically-bound variable with the given initial value.

** =dlet <dynamic> <value> . <exprs> → result= [operative]

Performs expressions with the dynamic variable bound to the value.

** =dref <dynamic> → value= [applicative]

Retrieves the dynamically-bound value of a dynamic variable.

* Types
** =make-type → (type tagger untagger)= [applicative]

Returns a list containing:

 * a fresh first-class type;

 * an applicative, the tagger, that takes a value and tags it with the
   type;

 * an applicative, the untagger, that takes a tagged object created by
   the tagger and returns its value.

The untagger only untags objects created by the tagger.

** =type-of <val> → type= [applicative]

Returns an object's type.  Every object has a type, whether built-in
objects or tagged objects.

** =Void=, =Ign=, =Boolean=, =Nil=, =Pair=, =Symbol=, =String=, =Number=, =Applicative=, =Operative=, =Environment=, =Vector=, =Type= [variables]

Type constants for built-in types.

** =void?=, =ign?=, =boolean?=, =null?=, =pair?=, =symbol?=, =string?=, =number?=, =applicative?=, =operative?=, =environment?=, =vector?=, =type?= [applicatives]

Type predicates for built-in types.

* Records
** =define-record-type <name> <ctor> <pred> . <fields> → type= [operative]

Defines a new record type with the given name.

=ctor= is of the form =(ctor-name . ctor-args)=.  =ctor-name= is bound
to a function that takes =ctor-args=, which must be record field
names, as arguments, and creates a new instance of the record type
with the given fields initialized to the arguments.

=pred= is bound to a function of one argument that returns true iff an
object is an instance of the record type.

Each element of =fields= is of the form:

 * =(name accessor-name)=, or

 * =(name accessor-name modifier-name)=.

*** Examples

#+BEGIN_EXAMPLE
(define-record-type Person
  (make-person name email)
  person?
  (name get-name set-name!)
  (email get-email set-email!))
#+END_EXAMPLE

* Generic Functions
** =define-generic (<name> . <args>) . [<body>] → generic= [operative]

Defines a new generic function.  If the optional body expressions are
supplied, a default method is installed that will be used when no
type-specific method is found.

** =define-method (<name> (<self> <type>) . <args>) . <body> → method= [operative]

Adds a method to a generic function.

*** Examples

#+BEGIN_EXAMPLE
(define-generic (->number obj))
(define-method (->number (self Number))
  self)
(define-method (->number (self String))
  (string->number self))
(define-method (->number (self Symbol))
  (string->number (symbol->string self)))
#+END_EXAMPLE

* Equality
** @<code>= <a> <b> → boolean@</code> [generic]

Generic equality predicate.  Different types may attach different
methods to this generic function.  If no method is defined for a type,
falls back to =eq?=.

Methods for the following types are predefined:

 * Two symbols are equal if they have the same string name.

 * Two numbers are equal if they are the same numerically.

 * Two strings are equal if they contain the same code points.

** @<code>/= <a> <b> → boolean@</code> [applicative]

Inequality predicate, defined in terms of @<code>=@</code>.

** =eq? <a> <b> → boolean= [applicative]

Returns true if the two values are pointer identical, false otherwise.

Note: it is advised against using =eq?= except in special
circumstances.  Because not even symbols or small numbers that "are
the same" are guaranteed to be =eq?=, it can be confusing.  The
generic equality predicate @<code>=@</code> should almost always be
used instead.

* Order
** =< <a> <b> → boolean= [generic]

Generic binary comparison function.  A method is defined for numbers.

** @<code>>@</code>, @<code><=@</code>, @<code>>=@</code> [applicatives]

Binary comparison functions defined in terms of =<= and @<code>=@</code>.

* Hashing
** =hash-code <obj> → number= [generic]

Generic hash function.  Different types may attach different methods
to this generic function.  If no method is defined for a type, falls
back to =identity-hash-code=.

If two objects are generically equal by @<code>=@</code>, their
generic hash codes must be equal, too.  Conversely, if two objects
have different generic hash codes, they cannot be generically equal.

** =identity-hash-code <obj> → number= [applicative]

Returns the system-determined identity hash code of the object, which
is equal if two objects are =eq?=.  It is unlikely that two different
objects have the same identity hash code.

* Conversion
** =->string <obj> → string= [generic]

Generic string conversion function.  Turns any object into a string.
Methods are defined for all built-in types.

** =string->symbol=, =symbol->string=, =string->number=, =number->string= [applicatives]
* Booleans
** =and=, =or= [operatives]

Short-circuiting binary logical connectives.

** =not= [applicative]

Unary logical connective.

* Numbers
** =+=, =-=, =*=, =/=, =%= [applicatives]

The binary applicatives for addition, subtraction, multiplication,
division, and modulo.

* Pairs and Lists

** =cons <car> <cdr> → cons= [applicative]

Creates a new cons with the given car and cdr.

** =car <pair> → value= [applicative]

Contents of the Address part of Register.

** =cdr <pair> → value= [applicative]

Contents of the Decrement part of Register.

** =caar=, =cadr=, =cdar=, =cddr= [applicatives]

Combinations of =car= and =cdr=, e.g. =(cadr x)= === =(car (cdr x))=.

** =list . <vals> → list= [applicative]

Constructs a nil-terminated list containing the values.

** =list* . <vals> → list= [applicative]

Constructs a list of the values, terminated by the last value.

* Vectors
** =vector . <elements> → vector= [applicative]

Creates a new vector with the given elements.

** =vector-ref <vector> <index> → element= [applicative]

Returns the vector's element at the given index.

** =vector-set! <vector> <index> <element> → element= [applicative]

Updates the vector's element at the given index and returns it.

** =vector-length <vector> → number= [applicative]

Returns the number of elements in the vector.

* Hashtables
** =Hashtable= [variable], =hashtable?= [applicative] /NIY/

Hashtable type and type predicate.

** =make-hashtable <hashfn> <eqfn> → hashtable= [applicative] /NIY/

Creates a new hashtable with the given hash function and equality function.

** =make-identity-hashtable → hashtable= [applicative]

Creates a new hashtable with =identity-hash-code= as hash function and =eq?= as
equality function.

** =make-generic-hashtable → hashtable= [applicative] /NIY/

Creates a new hashtable with =hash-code= as hash function and
@<code>=@</code> as equality function.

** =hashtable-put! <hashtable> <key> <val> → val= [applicative]

Associates key with value in hashtable.

** =hashtable-get <hashtable> <key> <default> → val= [applicative]

Returns value associated with key from hash, or default value if not
found.

* System
** =read → form= [applicative]

Reads a form from the console and returns it.

** =display <msg> → msg= [applicative]

Prints a message string to the console and returns it.

** =fail <reason> → |= [applicative]

Halts evaluation with an object describing the reason (typically an error).

* JavaScript Bridge 

The JavaScript object system is treacherous, so we don't even attempt
to somehow integrate it with Wat's.  It is urged to convert JavaScript
objects to Wat objects as early as possible with =from-js=, and
convert Wat objects to JavaScript objects as late as possible with
=to-js=.  JavaScript objects may not implement all Wat object
functionality, such as identity hash codes.

** =js-global <string> → result= [applicative]

Returns value of JavaScript global variable with given name.

** =js-set-global! <string> <val> → val= [applicative]

Updates value of JavaScript global variable with given name and returns it.

** =js-prop <object> <string> → result= [applicative]

Returns value of JavaScript member variable with given name of object.

** =js-set-prop! <object> <string> <val> → val= [applicative]

Updates value of JavaScript member variable with given name of object
and returns it.

** =js-function <jsfun> → applicative= [applicative]

Creates an applicative that when called will call the given JavaScript
function with the arguments it received.

** =js-method <string> → cmb= [applicative]

Creates an applicative that when called on an object and zero or more
arguments will invoke the method with the given string name of the
object with the given arguments.

** =to-js <obj> → jsobj= [applicative]

Tries to convert a Wat object, such as a string, to a similar
JavaScript object.
 
** =from-js <js-obj> → obj= [applicative]

Tries to convert a JavaScript object, such as a string, to a similar
Wat object.

** =js-callback <cmb> → jsfun= [applicative]

Returns a JS function that, when called, will apply the provided
combiner with the arguments the callback received.

** =define-js-method <name>= [operative]
=(define-js-method <name>)= is equivalent to =(define <name>
(js-method (symbol->string <name>)))=.
* Debugging Interface

** =stacktrace → list= [applicative] /NIY/

Returns a list of recent stack frames.

** =label <obj> → string= [applicative]

Returns the descriptive label of an object.

** =set-label! <obj> <string> → string= [applicative]

Updates the descriptive label of an object.

** =trap <exc> → |= [applicative] /NIY/

If an applicative named =trap= is defined in the top-level
environment, it will be called when an error (such as variable
unbound) happens during evaluation.

The trap should abort to a known good continuation, the current one is
broken and must not be resumed.
