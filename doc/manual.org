#+AUTHOR: Manuel Simoni
#+TITLE: Wat Language Manual
#+EMAIL: msimoni@gmail.com
#+OPTIONS: toc:t num:nil creator:nil
#+STYLE: <link rel="stylesheet" type="text/css" href="stylesheet.css"/>

* Description

/Wat/ is an ultra-lightweight dialect of Lisp, specifically
[[http://web.cs.wpi.edu/~jshutt/kernel.html][Kernel]], in which
everything is first-class: syntax, control, and data.  Syntax is based
on lexically-scoped fexprs and first-class environments, subsuming
ordinary procedures and hygienic macros.  Control is based on
delimited continuations and tail-call elimination, subsuming all
computational effects.  Data uses a dynamic type-tagging system that
allows generic programming over built-in as well as user-defined data
types.

Wat is hosted at <https://github.com/manuel/wat-js>.

This manual assumes familiarity with Kernel and Scheme.

* Lexical Structure

Wat has a mostly Scheme-like lexical structure, incompletely described
by the following table:

| ; ...                                         | /line comment/               |
| . + - [0-9]+                                  | /number/                     |
| #t #f                                         | /logical constants/          |
| #void #ign                                    | /void and ignore constants/  |
| " ... "                                       | /string/                     |
| \\ \" \n \r \t                                | /escape character in string/ |
| ( ... )                                       | /list/                       |
| ( a b . c )                                   | /dotted list/                |
| ()                                            | /nil/                        |
| a-z A-Z 0-9 - & ! : = > < % + ? / * # $ _ ' . | /symbol characters/          |
| '<expr>                                       | /short for/ =(quote <expr>)= |

Wat identifiers are case-sensitive.

* Built-in Types

 * Void :: The constant =#void= is used when there is no interesting
   value to return, or when a value is unspecified.

 * Ignore :: The constant =#ign= is used in parameter lists to indicate
   that an argument is ignored and should not be bound in the
   combiner's environment.

 * Boolean :: The =#t= constant represents logical truth and the =#f=
   constant represents logical falsity.

 * Number :: Wat currently only supports IEEE 754 floating-point
   numbers.

 * String :: Wat currently only supports UTF-16 encoded Unicode
   strings.

 * Symbol :: Symbols are used as identifiers for variable bindings.
   It is not guaranteed that symbols with the same name are pointer
   identical.

 * List :: Lists are built from immutable conses and nil.  Notably,
   lists often contain not only symbols and literals (as is usual in
   Lisp) but also first-class objects such as combiners.

 * Environment :: An environment maps symbols to values.  It may have
   a parent environment in which symbols are looked up if they are not
   found in this environment.

 * Operative (combiner) :: A combiner that operates directly on its operands.

 * Applicative (combiner) :: A combiner that evaluates its operands, yielding an
   arguments list, which it passes to an underlying combiner.

 * Type (tag) :: A first-class type tag or just type is associated
   with every object.

 * Vector :: An array of objects.

* Pattern Matching

As in Kernel, parameters and left-hand sides of definitions may not
only be symbols, but parameter trees: a parameter tree is either a
symbol, a cons, nil, or ignore.  A symbol binds the right hand to its
name, a cons recursively matches its car and cdr, nil matches only
nil, and ignore simply ignores the right-hand side.

Examples:

| Left-hand side | Right-hand side | Match results         |
|----------------+-----------------+-----------------------|
| a              | (1 (2) 3)       | a → (1 (2) 3)         |
| (a . b)        | (1 (2) 3)       | a → 1, b → ((2) 3)    |
| (a b c)        | (1 (2) 3)       | a → 1, b → (2), c → 3 |
| (a (b) . #ign) | (1 (2) 3)       | a → 1, b → 2          |

* Combiners

All computations in Wat are carried out by combiners, of which there
are two different kinds: operative and applicative.  An operative
combiner or just operative is a fexpr that receives the current
lexical environment and acts on its operand tree unevaluated.  An
applicative combiner or just applicative is a procedure that first
evaluates its operand tree and then passes the obtained arguments list
to an underlying combiner.  =vau= is the constructor of user-defined
operatives, called compound operatives.  =wrap= creates an applicative
around an underlying combiner.

Examples:

| Combiner                | Operand Tree  | Result                      |
|-------------------------+---------------+-----------------------------|
| =(vau x #ign x)=       | (1 (+ 2 3) 4) | (1 (+ 2 3) 4)               |
| =(vau #ign e e)=       | (1 (+ 2 3) 4) | /<the current environment>/ |
| =(wrap (vau x #ign x))= | (1 (+ 2 3) 4) | (1 5 4)                     |

* Core

The core contains primitive functionality that could not be
implemented in Wat itself (or it would be cumbersome to do so).

** Basics
*** =def <lhs> <rhs> → rhs= [operative]

Evaluates the right-hand side, matches the left-hand side against it
in the current environment, and returns it.

*** =begin . <exprs> → result= [operative]

Evaluates expressions from left to right, returning the value of the
last.  As a special case, =(begin)= returns void.

Note: =begin= could be implemented in the library, but for performance
reasons is built into the core.

*** =if <test> <then> <else> → result= [operative]

Evaluates the test, and if it is false evaluates the else branch,
otherwise evaluates the then branch.  The branches are evaluated in
tail position.

*** =cons <car> <cdr> → cons= [applicative]

Creates a new cons with the given car and cdr.

*** =eq? <a> <b> → boolean= [applicative]

Returns true if the two values are pointer identical, false otherwise.

** Vau Calculus
*** =vau <ptree> <envp> <body> → operative= [operative]

Constructs a new compound operative that closes over the current
environment with the given parameter tree, environment parameter, and
body expression.

*** =eval <expr> <env> → result= [applicative]

Evaluates the expression in the given environment.  The expression is
evaluated in tail-position.

*** =wrap <cmb> → applicative= [applicative]

Returns an applicative around an underlying combiner.

*** =unwrap <cmb> → combiner= [applicative]

Returns the underlying combiner of an applicative.

*** =make-environment [<parent>] → environment= [applicative]

Creates a new empty environment with the given optional parent.

** Control

These are the control operators from Dybvig, Jones, and Sabry's
[[http://www.cs.indiana.edu/~dyb/pubs/monadicDC.pdf][/A Monadic
Framework for Delimited Continuations/]] that are able to express all
other delimited control operators.

*** =make-prompt → prompt= [applicative]

Creates a fresh prompt.

*** =push-prompt* <prompt> <thunk> → result= [applicative]

Pushes the continuation-delimiting prompt and executes thunk in the
new continuation.

*** =take-sub-cont* <prompt> <cmb> → result= [applicative]

Aborts up to and including the prompt, and calls the combiner with a
single argument representing the delimited continuation from the call
to =take-sub-cont*= up to but not including the prompt.

*** =push-sub-cont* <cont> <thunk> → result= [applicative]

Prepends the delimited continuation to the current continuation, and
executes thunk in the new continuation.

** Types
*** =make-type → (type tagger untagger)= [applicative]

Returns a list containing:

 * a fresh first-class type;

 * an applicative, the tagger, that takes a value and tags it with the
   type;

 * an applicative, the untagger, that takes a tagged object created by
   the tagger and returns its value.

The untagger only untags objects created by the tagger.

*** =type-of <val> → type= [applicative]

Returns an object's type.  Every object has a type, whether built-in
objects or tagged objects.

** System

*** =read → form= [applicative]

Reads a form from the console and returns it.

*** =display <msg> → msg= [applicative]

Prints a message string to the console and returns it.

*** =fail <reason> → |= [applicative]

Halts evaluation with an object describing the reason (typically an error).

** Vectors

*** =vector . <elements> → vector= [applicative]

Creates a new vector with the given elements.

*** =vector-ref <vector> <index> → element= [applicative]

Returns the vector's element at the given index.

*** =vector-set! <vector> <index> <element> → element= [applicative]

Updates the vector's element at the given index and returns it.

*** =vector-length <vector> → number= [applicative]

Returns the number of elements in the vector.

* Library

The library consists of definitions written in Wat itself.

** Common

*** =lambda <ptree> . <exprs> → applicative= [operative]

Creates an applicative combiner, as in Scheme.

*** =apply <apv> <args> → result= [applicative]

Applies an applicative to an arguments list.

*** =quote <form> → form= [operative]

Returns form unevaluated.

*** =define <lhs> <rhs> → result= [operative]

Scheme-like =define= with two cases:

 * =(define <name> <value>)= simply binds name to value, returning value.

 * =(define (<name> . <params>) . <body>)= binds name to an
   applicative with the given parameters and body expressions,
   returning the applicative.

*** =define-syntax <lhs> <rhs> → result= [operative]

Scheme-like =define-syntax= with two cases:

 * =(define-syntax <name> <value>)= simply binds name to value,
   returning value.

 * =(define-syntax (<name> . <params>) <envparam> . <body>)= binds
   name to an operative with the given parameters, environment
   parameter, and body expressions, returning the operative.

*** =provide <names> . <exprs> → result= [operative]

Performs expressions in a new lexical scope and exports only listed
names to the outer scope.

#+BEGIN_EXAMPLE
(provide (foo bar)
  (def foo 1)
  (def bar 2)
  (def quux 3)
)
foo → 1
bar → 2
quux → error: unbound variable
#+END_EXAMPLE

** Pairs and Lists

*** =car <pair> → value= [applicative]

Contents of the Address part of Register.

*** =cdr <pair> → value= [applicative]

Contents of the Decrement part of Register.

*** =caar=, =cadr=, =cdar=, =cddr= [applicatives]

Combinations of =car= and =cdr=, e.g. =(cadr x)= === =(car (cdr x))=.

*** =null? <val> → boolean= [applicative]

Returns true if a value is nil, the empty list, false otherwise.

*** =pair? <val> → boolean= [applicative]

Returns true if a value is a pair (cons), false otherwise.

*** =list . <vals> → list= [applicative]

Constructs a nil-terminated list containing the values.

*** =list* . <vals> → list= [applicative]

Constructs a list of the values, terminated by the last value.

** Dynamic Binding

These are the operators from Kiselyov, Shan, and Sabry's
[[http://okmij.org/ftp/papers/DDBinding.pdf][/Delimited Dynamic Binding/]].

*** =dnew → dynamic= [applicative]

Creates a new dynamically-bound variable.

*** =dlet <dynamic> <value> . <exprs> → result= [operative]

Performs expressions with the dynamic variable bound to the value.

*** =dref <dynamic> → value= [applicative]

Retrieves the dynamically-bound value of a dynamic variable.

* External
** JavaScript Bridge

*** =js-global <string> → result= [applicative]

Returns value of JavaScript global variable with given name.

*** =js-set-global! <string> <val> → val= [applicative]

Updates value of JavaScript global variable with given name and returns it.

*** =js-prop <object> <string> → result= [applicative]

Returns value of JavaScript member variable with given name of object.

*** =js-set-prop! <object> <string> <val> → val= [applicative]

Updates value of JavaScript member variable with given name of object
and returns it.

*** =js-function <jsfun> → applicative= [applicative]

Creates an applicative that when called will call the given JavaScript
function with the arguments it received.

*** =js-method <string> → cmb= [applicative]

Creates an applicative that when called on an object and zero or more
arguments will invoke the method with the given string name of the
object with the given arguments.

*** =js-callback <cmb> → jsfun= [applicative]

Creates a JavaScript function that when called will call the given
combiner with the arguments it received.
 
*** =to-js <obj> → jsobj= [applicative]

Try to convert an object, such as a string, to a usable JavaScript
object.
 
*** =from-js <js-obj> → obj= [applicative]

Try to convert a JavaScript object, such as a string, to a usable Wat
object.
