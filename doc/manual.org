#+TITLE: Wat Language Manual
#+AUTHOR: Manuel Simoni
#+EMAIL: msimoni@gmail.com
#+OPTIONS: toc:t num:nil creator:nil
#+STYLE: <link rel="stylesheet" type="text/css" href="stylesheet.css"/>

* Description

/Wat/ is an ultra-lightweight dialect of Lisp, specifically [[http://web.cs.wpi.edu/~jshutt/kernel.html][Kernel]], in
which everything is first-class: syntax, control, and data.  Syntax is
based on lexically-scoped fexprs and first-class environments,
subsuming ordinary procedures and hygienic macros.  Control is based
on first-class continuations and tail-call elimination, subsuming all
known control structures.  Data uses a dynamic type-tagging system
that allows generic programming over built-in as well as user-defined
data types.

Wat is hosted at <https://github.com/manuel/wat-js>.

This manual assumes familiarity with Kernel and Scheme.

* Lexical Structure

Wat has a mostly Scheme-like lexical structure, incompletely described
by the following table:

| ; ...                                         | /line comment/               |
| . + - [0-9]+                                  | /number/                     |
| #t #f                                         | /logical constants/          |
| #void #ign                                    | /void and ignore constants/  |
| " ... "                                       | /string/                     |
| \\ \" \n \r \t                                | /escape character in string/ |
| ( ... )                                       | /list/                       |
| ( a b . c )                                   | /dotted list/                |
| ()                                            | /nil/                        |
| a-z A-Z 0-9 - & ! : = > < % + ? / * # $ _ ' . | /symbol characters/          |
| '<expr>                                       | /short for/ =(quote <expr>)= |

Wat identifiers are case-sensitive.

* Built-in Types

 * Void :: The constant =#void= is used when there is no interesting
   value to return, or when a value is unspecified.

 * Ignore :: The constant =#ign= is used in parameter lists to indicate
   that an argument is ignored and should not be bound in the
   combiner's environment.

 * Boolean :: The =#t= constant represents logical truth and the =#f=
   constant represents logical falsity.

 * Number :: Wat currently only supports IEEE 754 floating-point
   numbers.

 * String :: Wat currently only supports UTF-16 encoded Unicode
   strings.

 * Symbol :: Symbols are used as identifiers for variable bindings.
   It is not guaranteed that symbols with the same name are pointer
   identical.

 * List :: Lists are built from immutable conses and nil.  Notably,
   lists often contain not only symbols and literals (as is usual in
   Lisp) but also first-class objects such as combiners.

 * Environment :: An environment maps symbols to values.  It may have
   a parent environment in which symbols are looked up if they are not
   found in this environment.

 * Operative (combiner) :: A combiner that operates directly on its operands.

 * Applicative (combiner) :: A combiner that evaluates its operands, yielding an
   arguments list, which it passes to an underlying combiner.

 * Type (tag) :: A first-class type tag or just type is associated
   with every object, discussed in the next section.

 * Vector :: An array of objects.

* Type Tags

Every object in Wat has a type tag or just type.  A type is a
first-class object that contains an (initially empty) environment into
which programmers may store metadata.  Type tags are provided for all
built-in types, and there are routines for creating new types and
tagged objects that wrap an underlying value with a type.  Type tags
allow the definition of type systems in userland that interoperate
with the built-in types.

By principle, Wat does not support fully encapsulated data, i.e. data
that cannot be inspected from the outside.  Total visibility into the
running program for debugging and introspection is valued over the
ability to create total abstraction.  A better design based on
mirror-based reflection is probably possible.

* Pattern Matching

As in Kernel, parameters and left-hand sides of definitions may not
only be symbols, but parameter trees: a parameter tree is either a
symbol, a cons, nil, or ignore.  A symbol binds the right hand to its
name, a cons recursively matches its car and cdr, nil matches only
nil, and ignore simply ignores the right-hand side.

Examples:

| Left-hand side | Right-hand side | Match results         |
|----------------+-----------------+-----------------------|
| a              | (1 (2) 3)       | a → (1 (2) 3)         |
| (a . b)        | (1 (2) 3)       | a → 1, b → ((2) 3)    |
| (a b c)        | (1 (2) 3)       | a → 1, b → (2), c → 3 |
| (a (b) . #ign) | (1 (2) 3)       | a → 1, b → 2          |

* Combiners

All computations in Wat are carried out by combiners, of which there
are two different kinds: operative and applicative.  An operative
combiner or just operative is a fexpr that receives the current
lexical environment and acts on its operand tree unevaluated.  An
applicative combiner or just applicative is a procedure that first
evaluates its operand tree and then passes the obtained arguments list
to an underlying combiner.  =vau= is the constructor of user-defined
operatives, called compound operatives.  =wrap= creates an applicative
around an underlying combiner.

Examples:

| Combiner                | Operand Tree  | Result                      |
|-------------------------+---------------+-----------------------------|
| =(vau x #ign x)=       | (1 (+ 2 3) 4) | (1 (+ 2 3) 4)               |
| =(vau #ign e e)=       | (1 (+ 2 3) 4) | /<the current environment>/ |
| =(wrap (vau x #ign x))= | (1 (+ 2 3) 4) | (1 5 4)                     |

* Core

The core contains primitive functionality that could not be
implemented in Wat itself (or it would be cumbersome to do so).

** Vau Calculus
*** =def <lhs> <rhs> → rhs= [operative]

Evaluates the right-hand side, matches the left-hand side against it
in the current environment, and returns it.

*** =vau <ptree> <envp> <body> → operative= [operative]

Constructs a new compound operative that closes over the current
environment with the given parameter tree, environment parameter, and
body expression.

*** =eval <expr> <env> → result= [applicative]

Evaluates the expression in the given environment.  The expression is
evaluated in tail-position.

*** =wrap <cmb> → applicative= [applicative]

Returns an applicative around an underlying combiner.

*** =unwrap <cmb> → combiner= [applicative]

Returns the underlying combiner of an applicative.

*** =make-environment [<parent>] → environment= [applicative]

Creates a new empty environment with the given optional parent.

** Control Flow
*** =if <test> <then> <else> → result= [operative]

Evaluates the test, and if it is false evaluates the else branch,
otherwise evaluates the then branch.  The branches are evaluated in
tail position.

*** =ccc <cmb> → result= [applicative]

Calls the combiner with the current continuation as argument.  The
combiner is called in tail position.

=ccc= is the lowlevel facility for non-winding continuations; users
should almost certainly use the higher-level =call/cc= instead.

*** =jump <cont> <val> → |= [applicative]

Invokes the given continuation with the given value.

Because =ccc= is not to be used by users anyway, no effort is made to
make continuations created by it appear as applicatives.  Instead,
they are exposed directly, and therefore need a jump primitive for
invoking them.

*** =call-with-mark <key> <val> <thunk> → result= [operative]

Calls thunk in a continuation with a continuation mark mapping key to
value.  If the current continuation already has a mark with that key,
it is overwritten.  Thunk is evaluated in tail position.

*** =current-marks <key> → list= [applicative]

Returns a list of the current continuation marks with the given key,
from innermost to outermost continuation.

** Types
*** =make-type → type= [applicative]

Creates a new type with an empty environment.

*** =type-environment <type> → environment= [applicative]

Returns the type's environment for storing metadata.

*** =type-of <val> → type= [applicative]

Returns an object's type.

*** =tag <type> <val> → tagged= [applicative]

Creates a new user-tagged object with a type and wrapping an
underlying value.

*** =untag <tagged> → value= [applicative]

Returns the underlying value of a user-tagged object.

** Common
*** =eq? <a> <b> → boolean= [applicative]

Returns true if the two values are pointer identical, false otherwise.

*** =cons <car> <cdr> → cons= [applicative]

Creates a new cons with the given car and cdr.

*** =display <msg> → msg= [applicative]

Prints a message string to the console and returns it.

*** =fail <reason> → |= [applicative]

Halts evaluation with an object describing the reason (typically an error).

** Vectors

*** =vector . <elements> → vector= [applicative]

Creates a new vector with the given elements.

*** =vector-ref <vector> <index> → element= [applicative]

Returns the vector's element at the given index.

*** =vector-set! <vector> <index> <element> → element= [applicative]

Updates the vector's element at the given index and returns it.

*** =vector-length <vector> → number= [applicative]

Returns the number of elements in the vector.

* Library

The library consists of definitions written in Wat itself.

** Common

*** =lambda <ptree> . <exprs> → applicative= [operative]

Creates an applicative combiner, as in Scheme.

*** =apply <apv> <args> → result= [applicative]

Applies an applicative to an arguments list.

*** =set! <env> <lhs> <rhs> → rhs= [operative]

Updates the left-hand side bindings by matching it against the
right-hand side in the given environment.

*** =quote <form> → form= [operative]

Returns form unevaluated.

*** =define <lhs> <rhs> → result= [operative]

Scheme-like =define= with two cases:

 * =(define <name> <value>)= simply binds name to value, returning value.

 * =(define (<name> . <args>) . <body>)= binds name to an applicative with
   the given arguments and body expressions, returning the applicative.

*** =define-syntax <name> <expr> → result= [operative]

Has simply the same effect as =def=, but is used for defining
operatives in code that uses Scheme-style =define= for defining
applicatives.

*** =provide <names> . <exprs> → result= [operative]

Performs expressions in a new lexical scope and exports only listed
names to the outer scope.

#+begin_example
(provide (foo bar)
  (def foo 1)
  (def bar 2)
  (def quux 3)
)
foo → 1
bar → 2
quux → error: unbound variable
#+end_example

** Pairs and Lists

*** =car <pair> → value= [applicative]


Contents of the Address part of Register.

*** =cdr <pair> → value= [applicative]

Contents of the Decrement part of Register.

*** =caar=, =cadr=, =cdar=, =cddr= [applicatives]

Combinations of =car= and =cdr=, e.g. =(cadr x)= === =(car (cdr x))=.

*** =null? <val> → boolean= [applicative]

Returns true if a value is nil, the empty list, false otherwise.

*** =pair? <val> → boolean= [applicative]

Returns true if a value is a pair (cons), false otherwise.

*** =list . <vals> → list= [applicative]

Constructs a nil-terminated list containing the values.

*** =list* . <vals> → list= [applicative]

Constructs a list of the values, terminated by the last value.

** Control Flow

*** =begin . <exprs> → result= [operative]

Evaluates expressions from left to right, returning the value of the
last.  As a special case, =(begin)= returns void.

*** =call/cc <cmb> → result= [applicative]

Calls the combiner with an applicative as argument, that when called
will pass its single argument to the current continuation.  The
combiner is called in tail position.

As opposed to =ccc=, continuations created by =call/cc= are winding,
i.e. they collaborate with =dynamic-wind=.

*** =dynamic-wind <pre-thunk> <value-thunk> <post-thunk> → result= [applicative]


*** =with-mark <key> <val> . <exprs> → result= [operative]

Shorthand for =call-with-mark= that doesn't need a thunk.

** Generic Programming

*** =define-generic (<name> . <args>) → generic= [operative]

Defines a new generic function with the given name.

*** =define-method (<name> (<self> <type>) . <args>) → method= [operative]

Defines a new method for a generic function.

*** =send <obj> <msg> <arg> → result= [applicative]

Sends object a message with an argument.

